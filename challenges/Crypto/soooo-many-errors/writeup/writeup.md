# Writeup
## Analysis

There is a LOT going on in this challenge. The main difficulty of this challenge is deciding which one of these odd configurations you should exploit for the flag. Once you find one the exploitation is not that hard. I am also almost certain that there are multiple ways to solve this one, I can think of three methods that would probably work, but the one that I use in this writeup is the most simple.

## Solution 

I suspect that the method I use is not the intended way of doing things, because it completely ignores a good part of the script, but I don't know for sure.

It relies on this chunk here:
```python
if b == '1':
    cb = []
    for _ in range(e):
        ps = random.sample(secret_key, 2)
        p = dot_add(ps[0][0], ps[1][0])
        x = ps[0][1] + ps[1][1] + rand_err()
        cb.append((p, x))
    c.append(cb)
elif b == '0':
    cb = []
    for _ in range(e):
        p = rand_poly()
        x = random.randint(0, q-1)
        cb.append((p, x))
    c.append(cb)
```
The important part is this:
```python
p = dot_add(ps[0][0], ps[1][0])
```
The random polynomial is generated by adding two secret polynomials together for each `1` bit, but when the bit is `0` it is generated randomly:
```python
p = rand_poly()
```
Now if we take a look at how these secret polynomials are generated:
```python
def gen_key(n):
    samples = []
    for _ in range(n):
        p = rand_poly()
        x = dot_mul(p, s)
        samples.append((p, x))
    return samples
```
```python
secret_key = gen_key(50)
```
We can see that it only generates 50 of them, so if the secret polynomial is generated by adding two of them together, then there are only as many random possibilities as there are combinations of two polynomials. In this case that means that there are $\frac{50*49}{2}$ or $1225$ combinations. Considering how many of these things the program spits out, it would not be hard to enumerate all of them.

So I just needed to get the program to encrypt a bunch of `1` bits until I have them all. I noticed that the program cuts of leading `0`s when converting to binary, so if I tell it to encrypt a `?` which is `0x3f` in hex and `111111` in binary I can assume that all of the encrypted polynomials are fair game. 
```python
def get_polys():
    polys = []
    while len(polys) < 1225:
        r = requests.post('https://uscybercombine-s4-crypto-soooo-many-errors.chals.io/encrypt?m=%3f')
        data = eval(r.text)
        for b in data:
            for e in b:
                p = e[0]
                if p not in polys: polys.append(p)
        print(f"Enumerating Polynomials : {len(polys)}/1225",end='\r')
    return polys
```
Once I have all of the polynomial combinations I can go through each bit in the flag and test whether it is `1` or `0` by checking if its polynomials are in the list.
```python
def solve(polys):
    r = requests.get('https://uscybercombine-s4-crypto-soooo-many-errors.chals.io/get_flag')
    data = eval(r.text)
    flag_bin = ''
    for b in data:
        for e in b:
            p = e[0]
            if p not in polys: 
                flag_bin += '0'
                break
        else: flag_bin += '1'
    return long_to_bytes(int(flag_bin,2)).decode()
```
This will get me the flag.

Flag: `SIVUSCG{H0W_C4N_1_LeaRn_wItH_aLl_tHeSe_erR0r5}`